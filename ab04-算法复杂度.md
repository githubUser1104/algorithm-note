# 算法复杂度
https://github.com/youngyangyang04/leetcode-master

## 一、时间复杂度
1. 作用：定性描述该算法的运行时间。

2. 概念：假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。

3. 大O：数学上用来表示上界。算法最坏情况下运行时间的上界，就是对任意数据输入的运行时间的上界。但是算法上大O代表的是一般情况，而不是严格的上界。
![大O](https://img-blog.csdnimg.cn/20210408130000855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1YW5nX2FuZw==,size_16,color_FFFFFF,t_70)

4. 化简：**默认数据规模足够大**的条件下，去掉常数项、常数系数和低阶项  
例一：O(2*n^2 + 10*n + 1000)  => O(n^2)  
例二：时间复杂度logn可忽略底数  
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021040813133621.png)

5. 排行：O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)(立方阶) < O(2^n) (指数阶)

6. 实例分析：找出n个字符串中相同的两个字符串
- 方法一：暴力枚举，n^2 次的遍历加上每次字符串比较所需的m次操作（假设字符串的长度m）  
时间复杂度：O(m * n * n)
- 方法二：先使用快速排序进行比较 O(m * n * logn），得出按字母顺序的字符串集合；这时相同的字符串会挨在一起，所以只需要再遍历一次即可O(n * m)   
时间复杂度：O(m * n * logn + n * m)  => O(m * n * logn) 
- 通过时间复杂度的比较，方法二更优。

7.实际体验算法性能：https://mp.weixin.qq.com/s/73ryNsuPFvBQkt6BbhNzLA  
测试结果：2.7 GHz的CPU，一秒脉冲27亿次（有27亿个时钟周期），忽略其他因素的影响下，一秒可以在O(n)算法下处理的规模大约为5*10^8。

8.递归算法的时间复杂度：递归的次数 * 每次递归中的操作次数（每次递归中的时间复杂度）  
例子：求x的n次方  
方法一：非递归，O(n)  
```cpp
int function1(int x, int n) {
    int result = 1;  // 注意 任何数的0次方等于1
    for (int i = 0; i < n; i++) { result = result * x; }
    return result;
}
```
方法二：直接递归，递归了n次，每次一个乘法，时间复杂度是 n * 1 = O(n)
```cpp
int function2(int x, int n) {
    if (n == 0) { return 1; }
    return function2(x, n - 1) * x;
}
```
方法三：将x二分后再递归相乘，这个递归算法的时间复杂度依然是O(n)，分析如下
```cpp
int function3(int x, int n) {
    if (n == 0) { return 1; }
    if (n % 2 == 1) { return function3(x, n / 2) * function3(x, n / 2)*x; }
    return function3(x, n / 2) * function3(x, n / 2);
}
```
可以用二叉树显示递归过程，这棵树上每一个节点就代表着一次递归并进行了一次相乘操作，所以进行了多少次递归的话，就是看这棵树上有多少个节点。当n为16时如下图：
![递归时间复杂度分析](https://img-blog.csdnimg.cn/20210412102617403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1YW5nX2FuZw==,size_16,color_FFFFFF,t_70)
![递归时间复杂度计算](https://img-blog.csdnimg.cn/20210412102838650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1YW5nX2FuZw==,size_16,color_FFFFFF,t_70)

方法四：通过记录中间递归结果优化方法三，减少递归次数，时间复杂度是 log2n * 1 = O(logn)
```cpp
int function4(int x, int n) {
    if (n == 0) { return 1; }
    int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来并记录
    if (n % 2 == 1) { return t * t * x; } // 后续使用不需要再次递归了
    return t * t;
}
```

## 二、空间复杂度
1.概念与作用：对一个算法在运行过程中占用内存空间大小的量度

2.注意：有很多因素会影响程序真正内存使用大小，例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销。所以空间复杂度是预先大体评估程序内存使用的大小。

3.例子：
O(1)：随着n的变化，所需开辟的内存空间并不会随着n的变化而变化。
```cpp
int j = 0;
for (int i = 0; i < n; i++) { j++; }
```
O(n)：消耗空间和输入参数n保持线性增长
```cpp
int* a = new int(n);
for (int i = 0; i < n; i++) { a[i] = i; }
```
O(n^2)：消耗空间和输入参数n的平方保持线性增长，例如二维数组

递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度

可见，空间复杂度与数据结构关系很大


4.内存管理：不同的编程语言各自的内存管理方式  
C/C++这种内存堆空间的申请和释放完全靠自己管理，不规范的写法容易导致内存泄漏或内存溢出；而Java、Python正常情况下则不需要程序员去考虑内存泄漏的问题，虚拟机都做了这些事情。
![C/C++程序运行所需内存空间](https://img-blog.csdnimg.cn/20210412112539424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1YW5nX2FuZw==,size_16,color_FFFFFF,t_70)

想要算出自己程序会占用多少内存就一定要了解自己定义的数据类型的大小
![C/C++的数据类型大小](https://img-blog.csdnimg.cn/20210412113815906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1YW5nX2FuZw==,size_16,color_FFFFFF,t_70)

注意指针所占字节的变化，1个字节占8个比特，那么4个字节就是32个比特，可存放数据的大小为2^32，也就是4G空间的大小，即：可以寻找4G空间大小的内存地址。安装64位的操作系统的计算机内存都已经超过了4G，也就是指针大小如果还是4个字节的话，就已经不能寻址全部的内存地址，所以64位编译器使用8个字节的指针才能寻找所有的内存地址。

5.内存对齐：牺牲内存（通常影响不会太大）提高运行速度的技术  
为什么要有内存对齐？  
平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。  
硬件原因：经过内存对齐后，CPU访问内存的速度大大提升。  

例子说明：

```cpp
struct node{
   char cha;
   int num;
}st;
int main() {
    int a[100];
    char b[100];
    node st;
    cout << sizeof(int) << endl; // 4
    cout << sizeof(char) << endl; // 1
    cout << sizeof(a) << endl; // 400
    cout << sizeof(b) << endl; // 100
    cout << sizeof(st) << endl; // 8（由于内存对齐，所以结果不是5）
}
```
CPU读取内存不是一次读取单个字节，而是一块一块的来读取内存，块的大小可以是2，4，8，16个字节，具体取多少个字节取决于硬件。假设CPU把内存划分为4字节大小的块：  
![内存对齐](https://img-blog.csdnimg.cn/20210412114746970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1YW5nX2FuZw==,size_16,color_FFFFFF,t_70)

直接将地址4，5，6，7处的四个字节数据读取到即可，只需要一次寻址。  
![非内存对齐](https://img-blog.csdnimg.cn/20210412114829646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1YW5nX2FuZw==,size_16,color_FFFFFF,t_70)

首先CPU读取0，1，2，3处的四个字节数据  
CPU读取4，5，6，7处的四个字节数据  
合并地址1，2，3，4处四个字节的数据才是本次操作需要的int数据  
此时一共需要两次寻址，一次合并的操作。  

## 三、算法性能分析
例子一：斐波那契数的递归写法

```cpp
int fibonacci(int i) {
       if(i <= 0) return 0;
       if(i == 1) return 1;
       return fibonacci(i-1) + fibonacci(i-2);
}
```
时间复杂度分析：递归的次数 * 每次递归的时间复杂度
![斐波那契时间复杂度分析](https://img-blog.csdnimg.cn/20210412122432703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1YW5nX2FuZw==,size_16,color_FFFFFF,t_70)

一棵深度（按根节点深度为1）为k的二叉树最多可以有 2^k - 1 个节点，每次递归都是O(1)的操作，所以该递归算法的时间复杂度为 O(2^n)  
测试耗时：随着n的增大，耗时的增长也越来越快  
```cpp
#include <iostream>
#include <chrono>
#include <thread>
using namespace std;
using namespace chrono;
int fibonacci(int i) {
       if(i <= 0) return 0;
       if(i == 1) return 1;
       return fibonacci(i - 1) + fibonacci(i - 2);
}
void time_consumption() {
    int n;
    while (cin >> n) {
        milliseconds start_time = duration_cast<milliseconds >(
            system_clock::now().time_since_epoch()
        );

        fibonacci(n);

        milliseconds end_time = duration_cast<milliseconds >(
            system_clock::now().time_since_epoch()
        );
        cout << milliseconds(end_time).count() - milliseconds(start_time).count()
            <<" ms"<< endl;
    }
}
int main()
{
    time_consumption();
    return 0;
}
```
优化算法：用first和second来记录当前相加的两个数值，减少递归的次数，递归了n次，所以时间复杂度是 O(n)

```cpp
int fibonacci(int first, int second, int n) {
    if (n <= 0) { return 0; }
    if (n < 3) { return 1; }
    else if (n == 3) { return first + second; }
    else { return fibonacci(second, first + second, n - 1); }
}
```
测试耗时：比优化前的耗时少了很多

```cpp
#include <iostream>
#include <chrono>
#include <thread>
using namespace std;
using namespace chrono;
int fibonacci_3(int first, int second, int n) {
    if (n <= 0) { return 0; }
    if (n < 3) { return 1; }
    else if (n == 3) { return first + second; }
    else { return fibonacci_3(second, first + second, n - 1); }
}

void time_consumption() {
    int n;
    while (cin >> n) {
        milliseconds start_time = duration_cast<milliseconds >(
            system_clock::now().time_since_epoch()
        );
        fibonacci_3(0, 1, n);
        milliseconds end_time = duration_cast<milliseconds >(
            system_clock::now().time_since_epoch()
        );
        cout << milliseconds(end_time).count() - milliseconds(start_time).count()
            <<" ms"<< endl;
    }
}
int main()
{
    time_consumption();
    return 0;
}
```
空间复杂度分析：递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度  
每次递归所需的空间都被压到调用栈里（这是内存管理里面的数据结构，和算法里的栈原理是一样的），一次递归结束，这个栈就是就是把本次递归的数据弹出去。所以这个栈最大的长度就是递归的深度。  
此时可以分析这段递归的空间复杂度，从代码中可以看出每次递归所需要的空间大小都是一样的，所以每次递归中需要的空间是一个常量，并不会随着n的变化而变化，每次递归的空间复杂度就是O(1)。  
![递归空间复杂度](https://img-blog.csdnimg.cn/20210412180907476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1YW5nX2FuZw==,size_16,color_FFFFFF,t_70)

递归第n个斐波那契数的话，递归调用栈的深度就是n。那么每次递归的空间复杂度是O(1)， 调用栈深度为n，所以这段递归代码的空间复杂度就是O(n)。

例子二：二分查找

```cpp
int binary_search( int arr[], int l, int r, int x) {
    if (r >= l) {
        int mid = l + (r - l) / 2;
        if (arr[mid] == x)
            return mid;
        if (arr[mid] > x)
            return binary_search(arr, l, mid - 1, x);
        return binary_search(arr, mid + 1, r, x);
    }
    return -1;
}
```
时间复杂度：O(logn)  
空间复杂度：每次递归的空间复杂度可以看出主要就是参数里传入的这个arr数组，即O(n)。再来看递归的深度，二分查找的递归深度是logn ，递归深度就是调用栈的长度，那么这段代码的空间复杂度为 n * logn = O(nlogn)。

空间复杂度优化：把arr数组写成全局变量

```cpp
int arr[] = {2, 3, 4, 5, 8, 10, 15, 17, 20};
int binary_search(int l, int r, int n) {
    if (r >= l) {
        int mid = l + (r - l) / 2;
        if (arr[mid] == n)
            return mid;
        if (arr[mid] > n)
            return binary_search(l, mid - 1, n);
        return binary_search(mid + 1, r, n);
    }
    return -1;
}
```
这份代码将arr数组定义为全局变量，而不放在递归循环里，那么每层递归的空间复杂度是O(1)，递归深度为O(logn)，整体空间复杂度为 1 * logn = O(logn)。